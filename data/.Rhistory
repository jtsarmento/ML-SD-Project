ls()
?ls()
read.table(file.choose(),sep=",",header=TRUE)
read.table(file.choose(),sep=",",header=TRUE)
t = table(Class)
install.packages(c("dplyr", "ggplot2", "nycflights13"))
read.table(file.choose(),sep=",",header=TRUE)
install.packages(c("dplyr", "ggplot2", "nycflights13"))
dim(flights)
library(nycflights13)
dim(flights)
head(flights)
tail(flights)
filter(flights, month==1, day==1)
filter(flights,month==1,day==1)
f=filter(flights,month==1,day==1)
f=filter(flights,month==1,day==1)
install.packages("dplyr")
install.packages("dplyr")
install.packages("nycflights13")
install.packages("nycflights13")
library(nycflights13)
f=filter(flights,month==1,day==1)
x <- c(0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
# Calculating and plotting entropy for the binary case
?log2
# define function to measure the performance of a classification model
entropy <- function(p){
ifelse(p==0 | p==1, 0, -(p*log2(p)+(1-p)*log2(1-p)))
}
entropy(0.5)
entropy(0.99999)
entropy(1)
entropy(0)
x <- c(0,0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0)
y <- entropy(x)
plot(x,y, type="b", xlab="p", ylab="Entropy")
IG <- function(p, p1, p2, prop1){
entropy(p) - (prop1*entropy(p1)+(1-prop1)*entropy(p2))
}
IG(0.53, 0.92, 0.24, 0.43)
# We will now use the rpart package for decision tree classification
pkgs <- c("rpart", "rpart.plot", "party", "randomForest", "e1071")
#install.packages(pkgs,lib="C:/Rick/R/Rlib",depend=TRUE)
install.packages(pkgs, depend=TRUE)
?install.packages
?sample
?table
?rpart
# CUSTOMIZE DATA FILE: Define website that provides data file
loc <- "http://archive.ics.uci.edu/ml/machine-learning-databases/"
# CUSTOMIZE DATA FILE: Define data file
ds <- "breast-cancer-wisconsin/breast-cancer-wisconsin.data"
# Paste converts its arguments (via as.character) to character strings, and concatenates them (separating them by the string given by sep)
url <- paste(loc, ds, sep="")
# CUSTOMIZE DATA FILE: read.table reads a file in table format and creates a data frame from it
breast <- read.table(url, sep=",", header=FALSE, na.strings="?")
# CUSTOMIZE DATA FILE: Define column names
# CUSTOMIZE DATA FILE: The categorical dependent variable is called target
names(breast) <- c("ID", "clumpThickness", "sizeUniformity",
"shapeUniformity", "marginalAdhesion",
"singleEpithelialCellSize", "bareNuclei",
"blandChromatin", "normalNucleoli", "mitosis", "target")
# Define data frame containing all columns except first column
df <- breast[-1]
# CUSTOMIZE DATA FILE: factor relabels categorical values for a categorical variable
# CUSTOMIZE DATA FILE: The categorical dependent variable is called target
df$target <- factor(df$target, levels=c(2,4),
labels=c("benign", "malignant"))
# Define seed for random number generator
set.seed(1234)
# sample takes a random sample of the specified size from the elements of x
train <- sample(nrow(df), 0.7*nrow(df))
# Define training data frame using random sample of observations
df.train <- df[train,]
# Define validation data frame using all observations not in training data frame
df.validate <- df[-train,]
# CUSTOMIZE DATA: Table counts the observations for each categorical value of target
# CUSTOMIZE DATA: The categorical dependent variable is called target
table(df.train$target)
table(df.validate$target)
# Decision Tree
# library loads add-on packages
#library(rpart,lib="C:/Rick/R/Rlib")
library(rpart)
# Define seed for random number generator
set.seed(1234)
# Fit a recursive partitioning model
# CUSTOMIZE DATA: the first parameter target specifies the categorical dependent variable
# CUSTOMIZE DATA: The categorical dependent variable is called target
dtree <- rpart(target ~ ., data=df.train, method="class",
parms=list(split="information"))
# Summarize the decision tree including decision nodes and leaf nodes
# The decision tree nodes are described row by row, then left to right
summary(dtree)
# Display decision tree.  The true values follow the left branches.
plot(dtree);text(dtree)
# Display decision tree complexity parameter table which is a matrix of information on the optimal prunings based on a complexity parameter
# Identify CP that corresponds to the lowest xerror
dtree$cptable
# Plot complexity parameter table
plotcp(dtree)
# Determine CP that corresponds to the lowest xerror
# Get index of CP with lowest xerror
opt <- which.min(dtree$cptable[,"xerror"])
# get its CP value
cp <- dtree$cptable[opt, "CP"]
# Prune decision tree to decrease overfitting
dtree.pruned <- prune(dtree, cp)
# Display pruned decision tree.  The true values follow the left branches.
plot(dtree.pruned);text(dtree.pruned)
# class displays the object class
class(dtree$cptable)
# names displays the names of an object
names(dtree)
#library(rpart.plot,lib="C:/Rick/R/Rlib")
library(rpart.plot)
# Determine proportion of categorical dependent variable
# CUSTOMIZE DATA: The categorical dependent variable is called target
table(df.train$target)/nrow(df.train)
# prp plots an rpart model
prp(dtree.pruned, type=2, extra=104, fallen.leaves=TRUE, main="Decision Tree")
# predict evaluates the application of a model to a data frame
dtree.pred <- predict(dtree.pruned, df.validate, type="class")
# define classification matrix
# CUSTOMIZE DATA: The categorical dependent variable is called target
dtree.perf <- table(df.validate$target, dtree.pred, dnn=c("Actual", "Predicted"))
dtree.perf
# Random Forest
#library(randomForest,lib="C:/Rick/R/Rlib")
library(randomForest)
# Define seed for random number generator
set.seed(1234)
# Fit a random forest model
# The na.action=na.roughfix option replaces missing values on numeric variables with column medians and missing values on categorical variables with the modal category for that variable
# CUSTOMIZE DATA: The categorical dependent variable is called target
forest <- randomForest(target ~ ., data=df.train,
na.action=na.roughfix,
importance=TRUE)
# Display a summary for a random forest model
forest
# Display variable importance measures for a random forest model
importance(forest, type=2)
# predict evaluates the application of a model to a data frame
forest.pred <- predict(forest, df.validate)
# define classification matrix
# CUSTOMIZE DATA: The categorical dependent variable is called target
forest.perf <- table(df.validate$target, forest.pred,
dnn=c("Actual", "Predicted"))
forest.perf
source('C:/Users/Ryan Luu/Desktop/MSBA SUMMER \'19/BANA200A/Project 4/Classification Rev4.R')
install.packages("blogdown")
#Packages
library(tidyverse)
library(lubridate)
library(ggplot2)
library(randomForest)
library(caret)
library(chron)
#Set work directory
#setwd("C:/Users/Ryan Luu/Desktop/UCI/MSBA FALL '19/BANA273 - Machine Learning Analytics/Assignment 3")
setwd("C:/Users/Ryan Luu/Documents/GitHub/ML-SD-Project/data")
#read file
data <- read.csv("get_it_done_2019_requests_datasd_v1.csv")
#Remove unnecessary columns
data <- subset(data, select =-c(service_request_id, service_request_parent_id, sap_notification_number, park_name, referred, date_updated))
data$date_requested <- ymd_hms(data$date_requested)
#Look at only closed cases
data <- data[which(data$status == 'Closed')]
data <- data[which(data$lat > 32.5444 &
data$lat < 33.4274 &
data$lng < -117.0301 &
data$lng > -117.6126),]
table(data$status)
#Make new column as months
data$month <- month(data$date_requested)
data$month[data$month == 1] = 'Jan'
data$month[data$month == 2] = 'Feb'
data$month[data$month == 3] = 'Mar'
data$month[data$month == 4] = 'Apr'
data$month[data$month == 5] = 'May'
data$month[data$month == 6] = 'Jun'
data$month[data$month == 7] = 'Jul'
data$month[data$month == 8] = 'Aug'
data$month[data$month == 9] = 'Sep'
data$month[data$month == 10] = 'Oct'
data$month[data$month == 11] = 'Nov'
data$month[data$month == 12] = 'Dec'
data$month <- as.factor(data$month)
data$case_time[data$case_age_days < 8] = 'Short'
data$case_time[data$case_age_days >= 8 & data$case_age_days < 31] = 'Medium'
data$case_time[data$case_age_days >= 31] = 'Long'
data$council_district = paste0('District', sep='_', data$council_district)
#New Column Time -> extract time from date_requested
data$time <- format(ymd_hms(data$date_requested), "%H:%M:%S")
#Convert time variable from chr to time
data$time <- chron(times=data$time)
#New column Date -> extracts date from date_requested
data['date']<-as.Date(data$date_requested)
#New column Season based on Date column
data$season[data$date >= "2019-01-01" & data$date < "2019-03-21"] = "Winter"
data$season[data$date >= "2019-03-21" & data$date < "2019-06-21"] = "Spring"
data$season[data$date >= "2019-06-21" & data$date < "2019-09-21"] = "Summer"
data$season[data$date >= "2019-09-21" & data$date < "2019-12-21"] = "Fall"
#New column TOD based on time column
data$tod[data$time >= "00:00:00" & data$time < "05:59:59"] = "Past Midnight"
data$tod[data$time >= "06:00:00" & data$time < "11:59:59"] = "Morning"
data$tod[data$time >= "12:00:00" & data$time < "17:59:59"] = "Afternoon"
data$tod[data$time >= "18:00:00" & data$time < "23:59:59"] = "Evening"
#Change Variable Type
data$month <- as.factor(data$month)
data$council_district <- as.factor(data$council_district)
data$comm_plan_code <- as.factor(data$comm_plan_code)
data$case_time <- as.factor(data$case_time)
#Take 10,000 random observations
data_s <- data[sample(nrow(data), 10000),]
#-----------------------------------------------------------------------------------------------
# 2018 dataset
data2018 <- read.csv("get_it_done_2018_requests_datasd_v1.csv")
data2018 <- subset(data2018, select =-c(service_request_id, service_request_parent_id, sap_notification_number, park_name, referred, date_updated, public_description))
data2018$date_requested <- ymd_hms(data2018$date_requested)
data2018 <- data2018[which(data2018$status == 'Closed'),]
data2018 <- data2018[which(data2018$lat > 32.5444 &
data2018$lat < 33.4274 &
data2018$lng < -117.0301 &
data2018$lng > -117.6126),]
#data2018 <- data2018[which(data2018$service_name == 'Graffiti Removal'),]
summary(data2018$case_age_days)
#Make new column as months
data2018$month <- month(data2018$date_requested)
data2018$month[data2018$month == 1] = 'Jan'
data2018$month[data2018$month == 2] = 'Feb'
data2018$month[data2018$month == 3] = 'Mar'
data2018$month[data2018$month == 4] = 'Apr'
data2018$month[data2018$month == 5] = 'May'
data2018$month[data2018$month == 6] = 'Jun'
data2018$month[data2018$month == 7] = 'Jul'
data2018$month[data2018$month == 8] = 'Aug'
data2018$month[data2018$month == 9] = 'Sep'
data2018$month[data2018$month == 10] = 'Oct'
data2018$month[data2018$month == 11] = 'Nov'
data2018$month[data2018$month == 12] = 'Dec'
#new column case age days categorical
#data2018$case_time[data2018$case_age_days < 8] = 'Short'
#data2018$case_time[data2018$case_age_days >= 8 & data2018$case_age_days < 31] = 'Medium'
#data2018$case_time[data2018$case_age_days >= 31] = 'Long'
#-------------------------
data2018$case_time[data2018$case_age_days < 8] = 'Short'
data2018$case_time[data2018$case_age_days >= 8] = 'Long'
data2018$council_district = paste0('District', sep='_', data2018$council_district)
#New Column Time -> extract time from date_requested
data2018$time <- format(ymd_hms(data2018$date_requested), "%H:%M:%S")
#Convert time variable from chr to time
data2018$time <- chron(times=data2018$time)
#New column Date -> extracts date from date_requested
data2018['date']<-as.Date(data2018$date_requested)
#New column Season based on Date column
data2018$season[data2018$date >= "2018-01-01" & data2018$date < "2018-03-21"] = "Winter"
data2018$season[data2018$date >= "2018-03-21" & data2018$date < "2018-06-21"] = "Spring"
data2018$season[data2018$date >= "2018-06-21" & data2018$date < "2018-09-21"] = "Summer"
data2018$season[data2018$date >= "2018-09-21" & data2018$date < "2018-12-21"] = "Fall"
data2018$season[data2018$date >= "2018-12-21" & data2018$date < "2019-03-21"] = "Winter"
#New column TOD based on time column
data2018$tod[data2018$time >= "00:00:00" & data2018$time < "05:59:59"] = "Past Midnight"
data2018$tod[data2018$time >= "06:00:00" & data2018$time < "11:59:59"] = "Morning"
data2018$tod[data2018$time >= "12:00:00" & data2018$time < "17:59:59"] = "Afternoon"
data2018$tod[data2018$time >= "18:00:00" & data2018$time < "23:59:59"] = "Evening"
#convert variable type
data2018$month <- as.factor(data2018$month)
data2018$council_district <- as.factor(data2018$council_district)
data2018$comm_plan_code <- as.factor(data2018$comm_plan_code)
data2018$case_time <- as.factor(data2018$case_time)
str(data2018)
#Take 10,000 sample
data2018_s <- data2018[sample(nrow(data2018), 10000),]
#Load Train and Test datasets
#Identify feature and response variable(s) and values must be numeric and numpy arrays
#x_train <- input_variables_values_training_datasets
#y_train <- target_variables_values_training_datasets
#x_test <- input_variables_values_test_datasets
#x <- cbind(x_train,y_train)
# Train the model using the training sets and check score
#linear <- lm(y_train ~ ., data = x)
#summary(linear)
#Predict Output
#predicted= predict(linear,x_test)
set.seed(1234)
ind <- sample(2,nrow(data2018_s), replace = TRUE, prob = c(0.7,0.3))
train <- data2018_s[ind==1,]
test <- data2018_s[ind==2,]
poo <- "hello"
len(poo)
nchar(poo)
nchar(poo)
# 2018 dataset
data2018 <- read.csv("get_it_done_2018_requests_datasd_v1.csv")
data2018 <- subset(data2018, select =-c(service_request_id, service_request_parent_id, sap_notification_number, park_name, referred, date_updated))
data2018$date_requested <- ymd_hms(data2018$date_requested)
data2018 <- data2018[which(data2018$status == 'Closed'),]
data2018 <- data2018[which(data2018$lat > 32.5444 &
data2018$lat < 33.4274 &
data2018$lng < -117.0301 &
data2018$lng > -117.6126),]
#data2018 <- data2018[which(data2018$service_name == 'Graffiti Removal'),]
summary(data2018$case_age_days)
#Make new column as months
data2018$month <- month(data2018$date_requested)
data2018$month[data2018$month == 1] = 'Jan'
data2018$month[data2018$month == 2] = 'Feb'
data2018$month[data2018$month == 3] = 'Mar'
data2018$month[data2018$month == 4] = 'Apr'
data2018$month[data2018$month == 5] = 'May'
data2018$month[data2018$month == 6] = 'Jun'
data2018$month[data2018$month == 7] = 'Jul'
data2018$month[data2018$month == 8] = 'Aug'
data2018$month[data2018$month == 9] = 'Sep'
data2018$month[data2018$month == 10] = 'Oct'
data2018$month[data2018$month == 11] = 'Nov'
data2018$month[data2018$month == 12] = 'Dec'
#new column case age days categorical
#data2018$case_time[data2018$case_age_days < 8] = 'Short'
#data2018$case_time[data2018$case_age_days >= 8 & data2018$case_age_days < 31] = 'Medium'
#data2018$case_time[data2018$case_age_days >= 31] = 'Long'
#-------------------------
data2018$case_time[data2018$case_age_days < 8] = 'Short'
data2018$case_time[data2018$case_age_days >= 8] = 'Long'
data2018$council_district = paste0('District', sep='_', data2018$council_district)
#New Column Time -> extract time from date_requested
data2018$time <- format(ymd_hms(data2018$date_requested), "%H:%M:%S")
#Convert time variable from chr to time
data2018$time <- chron(times=data2018$time)
#New column Date -> extracts date from date_requested
data2018['date']<-as.Date(data2018$date_requested)
#New column Season based on Date column
data2018$season[data2018$date >= "2018-01-01" & data2018$date < "2018-03-21"] = "Winter"
data2018$season[data2018$date >= "2018-03-21" & data2018$date < "2018-06-21"] = "Spring"
data2018$season[data2018$date >= "2018-06-21" & data2018$date < "2018-09-21"] = "Summer"
data2018$season[data2018$date >= "2018-09-21" & data2018$date < "2018-12-21"] = "Fall"
data2018$season[data2018$date >= "2018-12-21" & data2018$date < "2019-03-21"] = "Winter"
#New column TOD based on time column
data2018$tod[data2018$time >= "00:00:00" & data2018$time < "05:59:59"] = "Past Midnight"
data2018$tod[data2018$time >= "06:00:00" & data2018$time < "11:59:59"] = "Morning"
data2018$tod[data2018$time >= "12:00:00" & data2018$time < "17:59:59"] = "Afternoon"
data2018$tod[data2018$time >= "18:00:00" & data2018$time < "23:59:59"] = "Evening"
#convert variable type
data2018$month <- as.factor(data2018$month)
data2018$council_district <- as.factor(data2018$council_district)
data2018$comm_plan_code <- as.factor(data2018$comm_plan_code)
data2018$case_time <- as.factor(data2018$case_time)
str(data2018)
#Take 10,000 sample
data2018_s <- data2018[sample(nrow(data2018), 10000),]
#Load Train and Test datasets
#Identify feature and response variable(s) and values must be numeric and numpy arrays
#x_train <- input_variables_values_training_datasets
#y_train <- target_variables_values_training_datasets
#x_test <- input_variables_values_test_datasets
#x <- cbind(x_train,y_train)
# Train the model using the training sets and check score
#linear <- lm(y_train ~ ., data = x)
#summary(linear)
#Predict Output
#predicted= predict(linear,x_test)
#set.seed(1234)
#ind <- sample(2,nrow(data2018_s), replace = TRUE, prob = c(0.7,0.3))
#train <- data2018_s[ind==1,]
#test <- data2018_s[ind==2,]
#poo <- "hello"
#data2018_s['p_len'] <-
poo <- "hello"
data2018_s['p_len'] <- data2018_s(nchar(data2018_s$public_description))
data2018_s['p_len'] <- nchar(data2018_s$public_description)
library(stringr)
data2018_s['p_len'] <- str_count(data2018_s$public_description)
data2018_s$p_len <- sapply(strsplit(data2018_s$public_description, " "), length)
table(unlist(strsplit(data2018_s$public_description, '\\s+'))
#write.csv(data2018_s, file = "data2018_for_luis.csv")
install.packages('qdap')
#write.csv(data2018_s, file = "data2018_for_luis.csv")
install.packages('qdap')
library(qdap)
word_count(poo)
data2018_s['p_len'] <- word_count(data2018_s$public_description)
drop(data2018_s['p_len'])
data2018_s['p_char'] <- str_count(data2018_s$public_description)
del(poo)
remove(poo)
data2018_s$p_len[data2018_s$p_len == NA] = 0
data2018_s$p_len[is.na(data2018_s$p_len)] <- 0
write.csv(data2018_s, file = "data2018_for_adam.csv")
